-- ========================================
-- PSG MX PLACEMENT APP - FUNCTIONS & VIEWS
-- ========================================
-- File 3 of 6: Helper Functions & Analytics Views
-- 
-- Creates functions for role checking, date validation,
-- and views for attendance summaries.
-- Run this AFTER 02_policies.sql
-- ========================================

-- ========================================
-- HELPER FUNCTIONS
-- ========================================

-- Check if user has a specific role
CREATE OR REPLACE FUNCTION has_role(user_id UUID, role_name TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    user_roles JSONB;
BEGIN
    SELECT roles INTO user_roles FROM users WHERE id = user_id;
    RETURN COALESCE((user_roles->>role_name)::BOOLEAN, FALSE);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Check if user is placement rep
CREATE OR REPLACE FUNCTION is_placement_rep(user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN has_role(user_id, 'isPlacementRep');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Check if user is coordinator
CREATE OR REPLACE FUNCTION is_coordinator(user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN has_role(user_id, 'isCoordinator');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Check if user is team leader
CREATE OR REPLACE FUNCTION is_team_leader(user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN has_role(user_id, 'isTeamLeader');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get user's team ID
CREATE OR REPLACE FUNCTION get_user_team(user_id UUID)
RETURNS TEXT AS $$
DECLARE
    user_team TEXT;
BEGIN
    SELECT team_id INTO user_team FROM users WHERE id = user_id;
    RETURN user_team;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Check if date is scheduled for attendance
CREATE OR REPLACE FUNCTION is_date_scheduled(check_date DATE)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM scheduled_attendance_dates 
        WHERE date = check_date
    );
END;
$$ LANGUAGE plpgsql STABLE;

-- Get scheduled dates in a range
CREATE OR REPLACE FUNCTION get_scheduled_dates(start_date DATE, end_date DATE)
RETURNS TABLE (
    id UUID,
    date DATE,
    scheduled_by UUID,
    notes TEXT,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sad.id,
        sad.date,
        sad.scheduled_by,
        sad.notes,
        sad.created_at,
        sad.updated_at
    FROM scheduled_attendance_dates sad
    WHERE sad.date >= start_date AND sad.date <= end_date
    ORDER BY sad.date ASC;
END;
$$ LANGUAGE plpgsql STABLE;

-- ========================================
-- FIX: LeetCode Username Synchronization
-- ========================================
-- The Unified Update Function
-- Call this from the method UserProvider.updateLeetCodeUsername
CREATE OR REPLACE FUNCTION update_leetcode_username_unified(
    p_user_id UUID,
    p_new_username TEXT
)
RETURNS VOID AS $$
DECLARE
    v_old_username TEXT;
    v_email TEXT;
BEGIN
    -- 1. Get current info (Before update)
    SELECT leetcode_username, email INTO v_old_username, v_email
    FROM users
    WHERE id = p_user_id;

    -- Trim whitespace just in case
    p_new_username := TRIM(p_new_username);

    -- 2. Update users table (The Source of Truth)
    UPDATE users
    SET leetcode_username = p_new_username,
        updated_at = NOW()
    WHERE id = p_user_id;

    -- 3. Update whitelist table (Keep registry in sync)
    IF v_email IS NOT NULL THEN
        UPDATE whitelist
        SET leetcode_username = p_new_username
        WHERE email = v_email;
    END IF;

    -- 4. Handle LeetCode Stats Table (Preserve History)
    IF v_old_username IS NOT NULL AND v_old_username != p_new_username THEN
        
        -- Check if the old username actually has stats
        IF EXISTS (SELECT 1 FROM leetcode_stats WHERE username = v_old_username) THEN
            
            -- Check if the NEW username already exists (collision)
            IF EXISTS (SELECT 1 FROM leetcode_stats WHERE username = p_new_username) THEN
                -- COLLISION: We cannot rename because the new name is already taken.
                -- Best Action: Delete the old artifact so we don't track stale data.
                -- The background fetcher will update the existing "new" record.
                DELETE FROM leetcode_stats WHERE username = v_old_username;
            ELSE
                -- NO COLLISION: Rename the old record to the new username.
                -- This preserves "total_solved", "ranking", etc.
                UPDATE leetcode_stats
                SET username = p_new_username,
                    last_updated = NOW() 
                WHERE username = v_old_username;
            END IF;
        END IF;
    END IF;

    -- 5. Helper: If no stats record exists at all for the new username (and we didn't just rename one),
    -- create a stub so the background fetcher picks it up faster.
    INSERT INTO leetcode_stats (username, total_solved, easy_solved, medium_solved, hard_solved)
    VALUES (p_new_username, 0, 0, 0, 0)
    ON CONFLICT (username) DO NOTHING;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ========================================
-- SUCCESS MESSAGE
-- ========================================
DO $$
BEGIN
    RAISE NOTICE '';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'âœ… STEP 3 COMPLETE: FUNCTIONS CREATED';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Functions Created:';
    RAISE NOTICE '  - has_role';
    RAISE NOTICE '  - is_placement_rep';
    RAISE NOTICE '  - is_coordinator';
    RAISE NOTICE '  - is_team_leader';
    RAISE NOTICE '  - get_user_team';
    RAISE NOTICE '  - is_date_scheduled';
    RAISE NOTICE '  - get_scheduled_dates';
    RAISE NOTICE '  - update_leetcode_username_unified';
    RAISE NOTICE '';
    RAISE NOTICE 'NEXT: Run 04_triggers.sql';
    RAISE NOTICE '========================================';
END $$;
